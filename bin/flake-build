#!/usr/bin/env nu

let eval_args = [
  "--gc-roots-dir", "gcroot",
] ++ (if $env.NIX_EVAL_ARGS? != null { 
  # dirty, but 🤷
  $env.NIX_EVAL_ARGS | split row " "
} else { [ ] })

def attic-setup [url: string, cache: string, token: string] {
  try {
    attic cache info $"main:($cache)"
  } catch {
    print $"⭐ Adding attic cache"
    attic login main $url --set-default $token
  }
  attic cache info $"main:($cache)"
}

def attic-use [cache: string] {
  attic use $"main:($cache)"
}

export def attic-upload [cache: string] {
  let paths = $in 

  if ($paths  | length) == 0 {
    print "‼️ No targets to push to attic. Skipping push"
  } else {
    print $"📤 Pushing to attic cache ($cache)"
    attic push --ignore-upstream-cache-filter --jobs 10 $"main:($cache)" $paths
  }
}

export def build-targets [--nom: bool = true] {
  let targets = $in | each { |target| $target | update drvPath ($target.drvPath | str replace --regex ".drv$" ".drv^*") }

  let command = if $nom { "nom" } else { "nix" }
  $targets | par-each --threads 2 { |target|
    let outPath = try {
      run-external --redirect-stdout $command build "--no-link" "--fallback" "--keep-going" "--json" $target.drvPath | from json | select outputs | flatten | get out
    } catch {
      null
    }
    { ...$target, outPath: $outPath }
  }
}

export def eval-targets [] {
  let targets = $in 

  $targets | par-each --threads 4 { |target| 
    nix-eval-jobs --workers 1 --flake $target $eval_args | lines | each {|l|
      $l | from json | select name drvPath
    }
  } | flatten
}

export def flake-input-targets [] {
  nix flake archive --json | from json | get inputs | transpose | select column0 column1.path | each { |c| 
    {name: $c.column0, outPath: [$c.column1_path], drvPath: null}
  }
}

export def gen-targets [--system: string] {
  try { rm -r gcroot/* }

  ['.#devShells', '.#packages'] | each {|target|
    nix eval $target --apply builtins.attrNames --json | from json | each { |sys|
      if $system != null and $system != $sys { continue }
      print $"🛗 Evaluating ($target).($sys)"

      nix-eval-jobs --workers 12 --flake $"($target).($sys)" $eval_args | lines | each {|l| 
        $l | from json | select name drvPath
      }
    } | flatten
  } | flatten
}

export def result-paths [] {
  $in | where outPath != null | get outPath | flatten 
}

def main [--attic-upload: bool = true, --attic-use: bool = false, --eval-only, --nom: bool = true, --system: string, ...targets: string ] {
  let attic_url = $env.ATTIC_URL?
  let attic_cache = $env.ATTIC_CACHE?
  let attic_token = $env.ATTIC_KEY?

  if $attic_use or $attic_upload {
    if ($attic_url == null) or ($attic_cache == null) or ($attic_token == null)) {
      print "‼️ attic information missing, abut ttic-use or attic-upload are set to true"
      exit 1
    }

    attic-setup $attic_url $attic_cache $attic_token

    if $attic_use {
      attic-use $attic_cache
    }
  }

  let targets = if $targets != [] { $targets | eval-targets } else { gen-targets --system=$system }

  print "🏛️ Targets"
  print $targets

  if $eval_only {
    exit 0
  }

  if ($targets | is-empty) {
    print $"⁉️ (ansi red)!! No targets from env PLUGIN_TARGETS or detected in flake, exiting(ansi reset)"
    exit 1
  }

  let built_targets = $targets | build-targets --nom=$nom 
  print "🎯 Built targets"
  print $built_targets

  if $attic_upload {
    flake-input-targets | merge $built_targets | result-paths | attic-upload $attic_cache
  }

  if ($built_targets | any { |t| $t.outPath == null }) {
    print "💀 Failed targets"
    print ($built_targets | where outPath == null)
    exit 1
  } else {
    print "🥳 Success!"
  }
}
