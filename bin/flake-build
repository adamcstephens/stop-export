#!/usr/bin/env nu

def attic-setup [url: string, cache: string, token: string] {
  try {
    attic cache info $"main:($cache)"
  } catch {
    print $"‚≠ê Adding attic cache"
    attic login main $url --set-default $token
  }
  attic cache info $"main:($cache)"
}

def attic-use [cache: string] {
  attic use $"main:($cache)"
}

export def attic-upload [cache: string] {
  let paths = $in

  if ($paths  | length) == 0 {
    print "‚ÄºÔ∏è No targets to push to attic. Skipping push"
  } else {
    print $"üì§ Pushing to attic cache ($cache)"
    attic push --ignore-upstream-cache-filter --jobs 10 $"main:($cache)" $paths
  }
}

export def build-targets [--nom: bool = true] {
  let targets = $in

  let command = if $nom { "nom" } else { "nix" }
  $targets | par-each --threads 2 { |target|
    let outPath = try {
      let drv = $target | update drvPath ($target.drvPath | str replace --regex ".drv$" ".drv^*") | get drvPath
      run-external --redirect-stdout $command build "--no-link" "--fallback" "--keep-going" "--json" $drv | from json | select outputs | flatten | get out
    } catch {
      null
    }
    { ...$target, outPath: $outPath }
  }
}

export def eval-targets [] {
  let targets = $in
  let eval_args = [
    "--gc-roots-dir", "gcroot",
  ] ++ (if $env.NIX_EVAL_ARGS? != null {
    # dirty, but ü§∑
    $env.NIX_EVAL_ARGS | split row " "
  } else { [ ] })

  $targets | par-each --threads 4 { |target|
    nix-eval-jobs --workers 1 --flake $target $eval_args | lines | each {|l|
      $l | from json | select name drvPath
    }
  } | flatten
}

export def flake-input-targets [] {
  nix flake archive --json | from json | get inputs | transpose | select column0 column1.path | each { |c|
    {name: $c.column0, outPath: [$c.column1_path], drvPath: null}
  }
}

export def gen-targets [--system: string] {
  try { rm -r gcroot/* }
  let eval_args = [
    "--gc-roots-dir", "gcroot",
  ] ++ (if $env.NIX_EVAL_ARGS? != null {
    # dirty, but ü§∑
    $env.NIX_EVAL_ARGS | split row " "
  } else { [ ] })

  ['.#devShells', '.#packages'] | each {|target|
    nix eval $target --apply builtins.attrNames --json | from json | each { |sys|
      if $system != null and $system != $sys { continue }
      print $"üõó Evaluating ($target).($sys)"

      nix-eval-jobs --workers 12 --flake $"($target).($sys)" $eval_args | lines | each {|l|
        $l | from json | select name drvPath
      }
    } | flatten
  } | flatten
}

export def result-paths [] {
  $in | where outPath != null | get outPath | flatten
}

def main [--attic-upload: bool = true, --attic-use: bool = false, --eval-only, --nom: bool = true, --system: string, ...targets: string ] {
  let attic_url = $env.ATTIC_URL?
  let attic_cache = $env.ATTIC_CACHE?
  let attic_token = $env.ATTIC_KEY?

  if $attic_use or $attic_upload {
    if ($attic_url == null) or ($attic_cache == null) or ($attic_token == null)) {
      print "‚ÄºÔ∏è attic information missing, abut ttic-use or attic-upload are set to true"
      exit 1
    }

    attic-setup $attic_url $attic_cache $attic_token

    if $attic_use {
      attic-use $attic_cache
    }
  }

  let targets = if $targets != [] { $targets | eval-targets } else { gen-targets --system=$system }

  print "üèõÔ∏è Targets"
  print $targets

  if $eval_only {
    exit 0
  }

  if ($targets | is-empty) {
    print $"‚ÅâÔ∏è (ansi red)!! No targets from env PLUGIN_TARGETS or detected in flake, exiting(ansi reset)"
    exit 1
  }

  let built_targets = $targets | build-targets --nom=$nom | append (flake-input-targets)
  print "üéØ Built targets"
  print ($built_targets | reject drvPath | each { |t| $t | update outPath ($t.outPath | str join "\n") })

  if $attic_upload {
    $built_targets | result-paths | attic-upload $attic_cache
  }

  if ($built_targets | any { |t| $t.outPath == null }) {
    print "üíÄ Failed targets"
    print ($built_targets | where outPath == null)
    exit 1
  } else {
    print "ü•≥ Success!"
  }
}
